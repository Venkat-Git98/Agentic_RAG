import {
  require_react
} from "./chunk-73THXJN7.js";
import {
  __toESM
} from "./chunk-2TUXWMP5.js";

// node_modules/use-undo/lib/use-undo.m.js
var import_react = __toESM(require_react());
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var ActionType;
(function(ActionType2) {
  ActionType2["Undo"] = "UNDO";
  ActionType2["Redo"] = "REDO";
  ActionType2["Set"] = "SET";
  ActionType2["Reset"] = "RESET";
})(ActionType || (ActionType = {}));
var initialState = {
  past: [],
  present: null,
  future: []
};
var useUndo = function useUndo2(initialPresent, opts) {
  if (opts === void 0) {
    opts = {};
  }
  var _useCheckpoints$opts = _extends({
    useCheckpoints: false
  }, opts), useCheckpoints = _useCheckpoints$opts.useCheckpoints;
  var reducer = function reducer2(state2, action) {
    var past = state2.past, present = state2.present, future = state2.future;
    switch (action.type) {
      case ActionType.Undo: {
        if (past.length === 0) {
          return state2;
        }
        var previous = past[past.length - 1];
        var newPast = past.slice(0, past.length - 1);
        return {
          past: newPast,
          present: previous,
          future: [present].concat(future)
        };
      }
      case ActionType.Redo: {
        if (future.length === 0) {
          return state2;
        }
        var next = future[0];
        var newFuture = future.slice(1);
        return {
          past: [].concat(past, [present]),
          present: next,
          future: newFuture
        };
      }
      case ActionType.Set: {
        var isNewCheckpoint = useCheckpoints ? !!action.historyCheckpoint : true;
        var newPresent = action.newPresent;
        if (newPresent === present) {
          return state2;
        }
        return {
          past: isNewCheckpoint === false ? past : [].concat(past, [present]),
          present: newPresent,
          future: []
        };
      }
      case ActionType.Reset: {
        var _newPresent = action.newPresent;
        return {
          past: [],
          present: _newPresent,
          future: []
        };
      }
    }
  };
  var _useReducer = (0, import_react.useReducer)(reducer, _extends({}, initialState, {
    present: initialPresent
  })), state = _useReducer[0], dispatch = _useReducer[1];
  var canUndo = state.past.length !== 0;
  var canRedo = state.future.length !== 0;
  var undo = (0, import_react.useCallback)(function() {
    if (canUndo) {
      dispatch({
        type: ActionType.Undo
      });
    }
  }, [canUndo]);
  var redo = (0, import_react.useCallback)(function() {
    if (canRedo) {
      dispatch({
        type: ActionType.Redo
      });
    }
  }, [canRedo]);
  var set = (0, import_react.useCallback)(function(newPresent, checkpoint) {
    if (checkpoint === void 0) {
      checkpoint = false;
    }
    dispatch({
      type: ActionType.Set,
      newPresent,
      historyCheckpoint: checkpoint
    });
  }, []);
  var reset = (0, import_react.useCallback)(function(newPresent) {
    return dispatch({
      type: ActionType.Reset,
      newPresent
    });
  }, []);
  return [state, {
    set,
    reset,
    undo,
    redo,
    canUndo,
    canRedo
  }];
};
var use_undo_m_default = useUndo;
export {
  use_undo_m_default as default
};
//# sourceMappingURL=use-undo.js.map
